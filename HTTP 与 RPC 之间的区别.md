## HTTP 与 RPC 之间的区别？

这是**后端架构和微服务面试的高频题**，面试官想考你对 **通信方式、调用方式、协议特点、性能和适用场景** 的理解。我给你整理成 **维度对比 + 面试总结一句话**，可直接背。

------

## 面试总结一句话

> **HTTP 更适合跨平台、对外接口，易于观察和调试；RPC 更适合内部高性能服务调用，调用感知像本地函数，但耦合度较高。**

------

## 一、核心对比表

| 维度     | HTTP                           | RPC                                |
| -------- | ------------------------------ | ---------------------------------- |
| 通信方式 | 文本协议 / 请求-响应           | 方法调用（本地感知）               |
| 协议类型 | 通用（HTTP/1.1、HTTP/2）       | 可基于 HTTP、TCP、自定义协议       |
| 调用方式 | REST 风格 / URL + 方法         | 类似函数调用，接口 + 参数          |
| 数据格式 | JSON / XML / HTML              | Protobuf / Thrift / Hessian / JSON |
| 耦合度   | 低（语言无关、跨平台）         | 高（服务端需要接口定义）           |
| 性能     | 较慢（文本解析、序列化开销大） | 高（可二进制协议，低延迟）         |
| 可观测性 | HTTP Status + Header           | 需要自定义监控 + 拦截器            |
| 适用场景 | 对外 API、跨语言系统           | 内部服务调用、高性能微服务         |

------

## 二、核心区别总结

1. **调用感知**
   - HTTP：像访问网页，依赖 URL + 方法
   - RPC：像本地函数调用，接口调用透明
2. **协议灵活性**
   - HTTP 通用，易扩展，跨平台
   - RPC 高性能，可定制协议、序列化方式
3. **性能差异**
   - HTTP 文本解析、JSON 序列化开销大
   - RPC 二进制协议 + 长连接性能更高
4. **语言和耦合**
   - HTTP：低耦合，跨语言
   - RPC：接口强绑定，跨语言需要 IDL（Protobuf / Thrift）

------

### 🔹 面试官可能追问

- ❓ RPC 如何保证跨语言调用？
- ❓ 为什么 HTTP 性能比 RPC 慢？
- ❓ gRPC 与 REST 的区别？
- ❓ 内部服务为什么选择 RPC 而非 HTTP？

## 1️⃣ RPC 如何保证跨语言调用？

**方案：**

1. **接口定义语言（IDL）**
   - 例如 Protobuf、Thrift
   - 定义服务接口 + 数据结构
2. **代码生成**
   - 根据 IDL 生成不同语言的客户端/服务端代码
3. **序列化协议**
   - 二进制序列化（Protobuf / Thrift）保证不同语言能正确解析数据

### 面试一句话

> **RPC 跨语言通过统一接口定义和二进制序列化协议保证调用兼容性。**

------

## 2️⃣ 为什么 HTTP 性能比 RPC 慢？

**原因：**

1. **文本协议开销大**
   - JSON / XML 解析慢
   - 文本比二进制大
2. **请求处理**
   - HTTP 每次请求可能建立新 TCP / TLS 连接（HTTP/1.1 可复用）
3. **调用方式**
   - HTTP REST 是 URL + 方法映射
   - RPC 类似本地函数调用，开销小

### 面试一句话

> **HTTP 因文本解析、序列化开销大以及调用方式比 RPC 更“重”，性能通常较低。**

------

## 3️⃣ gRPC 与 REST 的区别？

| 维度     | REST       | gRPC                          |
| -------- | ---------- | ----------------------------- |
| 协议     | HTTP/1.1   | HTTP/2                        |
| 数据格式 | JSON / XML | Protobuf（二进制）            |
| 调用方式 | URL + 方法 | 方法调用（IDL生成代码）       |
| 性能     | 较低       | 高（多路复用 + 二进制序列化） |
| 状态     | 无状态     | 可支持双向流、多路复用        |
| 可观测性 | 易于调试   | 需要工具（grpcurl / 拦截器）  |

### 面试一句话

> **gRPC 基于 HTTP/2 和 Protobuf，高性能、支持多路复用和双向流，适合内部服务；REST 易用、跨平台，适合对外接口。**

------

## 4️⃣ 内部服务为什么选择 RPC 而非 HTTP？

**原因：**

1. **性能高**
   - 二进制协议 + 长连接 + 多路复用
2. **调用感知像本地方法**
   - 开发更自然，接口强类型
3. **服务间强依赖**
   - 内部调用可承受接口绑定
   - 结合负载均衡、熔断、限流机制
4. **可扩展性**
   - 支持 IDL + 代码生成，便于多语言内部调用

### 面试一句话

> **内部服务选 RPC 是因为高性能、接口强类型、调用像本地方法，适合服务间频繁通信。**

------

### 🧠 高频追问速记版（面试背诵版）

> 1. RPC 跨语言靠 IDL + 序列化协议
> 2. HTTP 慢因文本解析和调用方式重
> 3. gRPC 高性能 + HTTP/2 + 二进制，REST 跨平台易用
> 4. 内部服务选 RPC 为高性能、强类型、低延迟