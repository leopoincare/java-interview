## 说说 TCP 的三次握手，四次挥手？

这是 **网络基础必考题**，但面试官真正想听的是：**为什么要三次、为什么挥手要四次、每一步在解决什么问题**。我按「**流程 → 原因 → 面试一句话**」给你讲清楚。

------

## 一、TCP 三次握手（建立连接）

### 1️⃣ 三次握手流程

```
客户端                服务端
  | —— SYN(seq=x) ——> |
  | <— SYN+ACK ——     |
  | —— ACK ——>        |
```

**步骤说明：**

1. **第一次**
   - 客户端发送 `SYN(seq=x)`
   - 进入 `SYN_SENT`
   - 表示：我要建立连接
2. **第二次**
   - 服务端回复 `SYN(seq=y) + ACK(x+1)`
   - 进入 `SYN_RCVD`
   - 表示：我收到了，并同意建立
3. **第三次**
   - 客户端发送 `ACK(y+1)`
   - 双方进入 `ESTABLISHED`

------

### 2️⃣ 为什么必须三次？（重点 ⭐）

#### 核心目的：**双方都确认对方的收发能力**

- 1 次：客户端 → 服务端（服务端知道客户端能发）
- 2 次：服务端 → 客户端（客户端知道服务端能发）
- 3 次：客户端 → 服务端（服务端知道客户端能收）

📌 **两次不够，四次多余**

------

### 3️⃣ 防止历史连接问题

- 旧的 `SYN` 报文可能延迟到达
- 三次握手能确保只建立**最新有效连接**

------

### 面试总结一句话

> **三次握手确保通信双方都具备收发能力，并避免历史连接请求导致的错误建立。**

------

## 二、TCP 四次挥手（断开连接）

### 1️⃣ 四次挥手流程

```
客户端                服务端
  | —— FIN ——>        |
  | <— ACK ——         |
  | <— FIN ——         |
  | —— ACK ——>        |
```

------

### 2️⃣ 四次挥手步骤说明

1. **第一次**
   - 主动方发送 `FIN`
   - 表示：我不再发送数据了
2. **第二次**
   - 被动方回复 `ACK`
   - 表示：我知道了
3. **第三次**
   - 被动方发送 `FIN`
   - 表示：我也不再发送数据了
4. **第四次**
   - 主动方回复 `ACK`
   - 双方关闭连接

------

### 3️⃣ 为什么挥手是四次？（重点 ⭐）

> **TCP 是全双工协议**

- 关闭是**两个方向独立进行**
- ACK 和 FIN 不能总是合并
- 服务端可能还有数据没发完

📌 建立连接可以合并（SYN+ACK），关闭不一定能合并

------

## 三、TIME_WAIT 为什么存在？

### 出现在谁身上？

- **主动关闭连接的一方**

### 作用（面试高频）

1. **保证最后一个 ACK 能被对方收到**
2. **防止旧连接的数据干扰新连接**

### 为什么是 2MSL？

- 一个 MSL：报文最大生存时间
- 两个方向都安全

------

### 面试总结一句话

> **TIME_WAIT 用于确保连接彻底关闭并避免旧报文影响新连接。**

------

## 四、三次握手 vs 四次挥手对比表 ⭐

| 对比项     | 三次握手 | 四次挥手   |
| ---------- | -------- | ---------- |
| 目的       | 建立连接 | 释放连接   |
| 次数       | 3 次     | 4 次       |
| 是否能合并 | SYN+ACK  | 不一定     |
| 协议特性   | 双向确认 | 全双工关闭 |

------

## 五、面试官常见追问（你可以继续答）

- ❓ 如果第三次 ACK 丢了怎么办？
- ❓ 为什么 TIME_WAIT 不在服务端？
- ❓ 能不能用两次挥手？
- ❓ TCP 半连接队列满了怎么办？

下面这 4 个问题是 **TCP 面试的“终极追问”**，我给你按 **发生什么 → 为什么这样设计 → 面试一句话** 的结构讲清楚，直接可背。

------

## 1️⃣ 如果第三次 ACK 丢了怎么办？

### 会发生什么？

- **客户端**：认为连接已经建立，进入 `ESTABLISHED`
- **服务端**：没收到 ACK，仍在 `SYN_RCVD`

### 接下来会怎样？

- 服务端会 **重发 SYN+ACK**
- 客户端收到后：
  - 再次发送 ACK
  - 或直接带 ACK 的数据包

📌 一旦服务端收到 ACK：

- 双方都进入 `ESTABLISHED`

### 会不会建立“半个连接”？

❌ 不会

- 服务端未确认前不会正式分配连接资源
- 超时后会释放半连接

### 面试一句话

> **第三次 ACK 丢失后，服务端会重传 SYN+ACK，直到收到 ACK 或超时释放，不会形成错误连接。**

------

## 2️⃣ 为什么 TIME_WAIT 不在服务端？

### 谁进入 TIME_WAIT？

- **主动关闭连接的一方**

------

### 原因一：保证最后一个 ACK 被对方收到

- 主动方发出最后 ACK
- 若丢失，需要重发
- 所以必须等待

### 原因二：防止旧连接报文干扰新连接

- 确保旧连接的报文全部消失（2MSL）

------

### 为什么通常是客户端？

- 客户端更常主动关闭
- 服务端需要快速释放资源，不能长期占用端口

📌 **不是“不能在服务端”，而是“不适合”**

### 面试一句话

> **TIME_WAIT 由主动关闭方承担，通常是客户端，以保证连接可靠关闭并避免影响新连接。**

------

## 3️⃣ 能不能用两次挥手？

### 理论上可以吗？

- **可以（在特殊情况下）**

### 什么情况下？

- 被动方：
  - 已经没有数据要发
  - 收到 FIN 时，可以立即回复 `FIN+ACK`

```
FIN  →  FIN+ACK  →  ACK
```

👉 看起来像 “两次半”

------

### 为什么协议设计为四次？

- TCP 是 **全双工**
- 发送和接收是两个独立方向
- 不能假设对方“立刻没数据”

### 面试一句话

> **两次挥手只在对方无数据可发时成立，TCP 设计四次挥手是为适配全双工通信的通用场景。**

------

## 4️⃣ TCP 半连接队列满了怎么办？

### 什么是半连接队列？

- 存放 `SYN_RCVD` 状态的连接
- 三次握手未完成

------

### 队列满的后果

- 新的 SYN：
  - 被丢弃
  - 或直接返回 RST
- 客户端表现为：
  - 连接超时
  - 连接被拒绝

------

### 解决方案（面试重点 ⭐）

#### 1️⃣ SYN Cookies（最重要）

- 不分配半连接资源
- 用 cookie 编码状态
- ACK 校验成功再建连接

#### 2️⃣ 调大队列

```
net.ipv4.tcp_max_syn_backlog
```

#### 3️⃣ 防 SYN Flood

- 防火墙
- 限流
- 负载均衡

------

### 面试一句话

> **半连接队列满时新连接会被丢弃或拒绝，通常通过 SYN Cookies 和调大 backlog 来解决。**

------

## 🧠 四连问速记总结（30 秒背完）

> - ACK 丢失后服务端重传 SYN+ACK
> - TIME_WAIT 由主动关闭方承担，通常是客户端
> - 两次挥手只适用于无数据场景
> - 半连接队列满靠 SYN Cookies 兜底