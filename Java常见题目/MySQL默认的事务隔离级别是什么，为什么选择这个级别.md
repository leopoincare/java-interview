## MySQL 默认的事务隔离级别是什么？为什么选择这个级别？

**MySQL（InnoDB）默认的事务隔离级别是：**

> 👉 **REPEATABLE READ（可重复读）**

------

## 面试一句话总结

> **MySQL InnoDB 默认使用 REPEATABLE READ 隔离级别，它在避免脏读和不可重复读的同时，结合 MVCC 和 Next-Key Lock 基本解决了幻读问题，在数据一致性和并发性能之间取得了最佳平衡。**

## 一、为什么是 REPEATABLE READ？（核心原因）

MySQL 选择 **可重复读（RR）**，是因为它在 **一致性、并发性能、实现成本** 之间取得了**最佳平衡**。

------

## 二、RR 能解决哪些并发问题？

| 并发问题   | RR 是否解决           |
| ---------- | --------------------- |
| 脏读       | ✅ 解决                |
| 不可重复读 | ✅ 解决                |
| 幻读       | ❌（但 InnoDB 可解决） |

⚠️ 重点补充：

> **InnoDB 在 RR 隔离级别下，通过 MVCC + Next-Key Lock，基本解决了幻读问题。**

------

## 三、为什么不用更低的隔离级别？

### 1️⃣ READ UNCOMMITTED（读未提交）

- 会出现脏读
- 数据不可靠
   ❌ 直接排除

------

### 2️⃣ READ COMMITTED（读已提交）

- Oracle 默认
- 存在不可重复读
- 一致性弱于 RR

👉 **MySQL 更强调事务内一致性视图**

------

## 四、为什么不用更高的隔离级别？

### SERIALIZABLE（串行化）

- 完全避免并发问题
- 所有事务串行执行
- 性能极差

❌ 不适合高并发 OLTP 场景

------

## 五、RR 在 InnoDB 中是如何实现的？

### 1️⃣ MVCC（多版本并发控制）

- 读操作不加锁
- 使用一致性快照
- 保证事务内多次读结果一致

------

### 2️⃣ Next-Key Lock（关键点）

- **记录锁 + 间隙锁**
- 防止范围查询被插入新记录
- 解决幻读问题

------

## 六、MySQL vs 其他数据库对比

| 数据库          | 默认隔离级别        |
| --------------- | ------------------- |
| MySQL（InnoDB） | **REPEATABLE READ** |
| Oracle          | READ COMMITTED      |
| PostgreSQL      | READ COMMITTED      |

------



## **MySQL 事务隔离级别延伸面试问题**整理成系统的答题方案，覆盖 **原理、区别、应用、陷阱**，非常适合面试快速回答。

------

## 一、RR 与 RC 在 MVCC 上的区别

| 特性       | READ COMMITTED (RC)  | REPEATABLE READ (RR)           |
| ---------- | -------------------- | ------------------------------ |
| 读取一致性 | 每次读都生成新的快照 | 事务开始时生成一次快照         |
| 可重复读   | ❌ 不保证             | ✅ 保证                         |
| 幻读       | ❌ 存在               | ❌ InnoDB 用 Next-Key Lock 解决 |
| MVCC 行为  | 读最新提交的版本     | 读事务开始时的版本             |

**面试回答要点**：

> RC 每次读都是最新提交的数据，事务内可能读到不同结果；RR 在事务内读的是同一版本，保证可重复读。

------

## 二、RR 下幻读是如何被解决的？

### 1️⃣ 问题

- 幻读发生在 **范围查询**，其他事务插入新行导致结果集变化

### 2️⃣ InnoDB 的解决方案

- **Next-Key Lock = 记录锁 + 间隙锁**
- 范围锁住数据区间，防止其他事务插入
- 示例：

```
SELECT * FROM orders WHERE amount > 100 FOR UPDATE;
```

- 锁住所有符合条件的行以及行间空隙
- 防止幻读出现

------

## 三、RR 下仍可能出现的问题

- 如果使用 **非 InnoDB 存储引擎**（如 MyISAM），幻读无法解决
- 只读事务不加锁时，如果没有 Next-Key Lock，幻读可能出现
- 大事务中锁粒度过大 → 可能影响并发性能

------

## 四、何时手动改为 READ COMMITTED？

- 事务冲突频繁，锁竞争严重 → RC 可以减少锁等待
- 对事务内重复读取一致性要求不高
- 适合 **OLTP 高并发场景**，比如日志统计、访问记录

------

## 五、典型面试追问题

### 1️⃣ MVCC 如何实现可重复读？

- 每行记录存储 **create / delete 事务 ID**
- 事务读取时根据版本判断可见性
- 事务内多次读同一行 → 读同一版本

### 2️⃣ Next-Key Lock 与行锁的区别？

| 锁类型        | 锁范围    | 防护对象     |
| ------------- | --------- | ------------ |
| 行锁          | 单行      | 该行修改冲突 |
| 间隙锁        | 行间空隙  | 防止插入幻行 |
| Next-Key Lock | 行 + 间隙 | 解决幻读     |

### 3️⃣ 为什么 SERIALIZABLE 性能低？

- 所有读操作都会加锁 → 并发事务串行化
- 对高并发 OLTP 不适合

------

## 六、面试答题思路（模板）

> 1️⃣ 先说默认隔离级别：**REPEATABLE READ**
>  2️⃣ 解释解决的问题：避免脏读和不可重复读
>  3️⃣ 幻读如何解决：**Next-Key Lock**
>  4️⃣ 对比 RC：RR 事务内读同一版本，RC 每次读最新提交
>  5️⃣ 性能考虑：RC 并发高，SERIALIZABLE 并发低
>  6️⃣ 场景选择：读多写少用 RR，高并发写多可改 RC