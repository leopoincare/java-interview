## 什么是协程，Java支持吗？

这是 **并发与高性能面试题**，很多人会混淆“线程”和“协程”。我按 **概念 → 特性 → Java 支持情况 → 面试总结** 给你整理清晰版。

------

## 面试总结一句话

> **协程是一种轻量级用户态线程，可以在一个线程内并发执行多个任务，Java 从 JDK 20 引入虚拟线程后开始支持类似协程的轻量级线程，适合高并发 I/O 密集型场景。**

## 一、什么是协程（Coroutine）？

> **协程是一种用户态的轻量级线程，它可以主动挂起和恢复执行，允许在一个线程中并发执行多个任务。**

### 核心特征

1. **轻量级**
   - 不依赖操作系统线程，每个线程可以挂载多个协程
   - 内存占用小，创建和切换开销低
2. **非抢占式调度**
   - 协程主动让出执行权（`yield` / `suspend`）
   - 与线程抢占式调度不同
3. **高并发场景适合 I/O 密集型任务**
   - 避免大量线程阻塞，提高吞吐量

------

## 二、协程 vs 线程

| 特性     | 线程                         | 协程                 |
| -------- | ---------------------------- | -------------------- |
| 调度方式 | 抢占式，由 OS 调度           | 非抢占式，由程序调度 |
| 内存开销 | 大（线程栈通常 1MB）         | 小（协程栈可共享）   |
| 切换开销 | 高（系统调用切换线程上下文） | 低（用户态切换）     |
| 适用场景 | CPU 密集型                   | I/O 密集型、高并发   |

------

## 三、Java 支持情况

### 1️⃣ 原生 Java

- **Java 直到 JDK 20 / 21 才引入** **虚拟线程（Virtual Threads）**，也称 **Project Loom**
- 虚拟线程是一种 **轻量级线程实现，类似协程**
- 创建和切换比传统线程开销低很多

```
// JDK 20+ 示例
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
executor.submit(() -> {
    System.out.println("Hello from virtual thread: " + Thread.currentThread());
});
executor.shutdown();
```

### 2️⃣ 第三方库

- Kotlin 协程（Kotlin/JVM）
- Quasar（Java 协程库）
- Reactor / Project Loom 风格的协程式异步编程

### 3️⃣ 传统 Java 实现协程

- 通过回调、Future、CompletableFuture、Reactive 编程模拟协程
- **但不是真正的用户态协程**

------

## 四、协程优点

- 极大减少线程开销 → 可支持百万级并发
- I/O 任务无需阻塞线程 → 提高吞吐量
- 易于组合异步逻辑（在 Kotlin / Loom 中更优雅）

------

