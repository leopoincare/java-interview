## Java 中的 final 关键字是否能保证变量的可见性？

这是一个**偏 JVM 内存模型（JMM）的高频面试题**，结论容易被误解。我直接给你 **结论 + 原理 + 例子 + 面试一句话**。

------

## 面试总结一句话 ⭐（必背）

> **`final` 不是通用的可见性关键字，但 Java 内存模型保证：只要对象被正确构造并安全发布，`final` 字段在构造完成后对所有线程可见。**

## 一、结论先行（很重要）

> **`final` 本身不是通用的可见性关键字，但对 `final` 修饰的字段，Java 内存模型提供了“初始化安全性保证”。**

换句话说：

- ❌ `final` ≠ `volatile`
- ✅ `final` 能保证 **构造完成后的字段对其他线程可见**

------

## 二、什么是 `final` 的可见性保证？

### 1️⃣ JMM 对 `final` 字段的特殊规定

Java 内存模型规定：

> **在对象构造完成后，`final` 字段的值对其他线程是可见的，即使没有同步。**

前提条件：

- 对象引用 **没有在构造函数中逸出**
- `final` 字段只在构造函数中赋值

------

### 2️⃣ JVM 底层做了什么？

- 编译器在构造函数结束时插入 **StoreStore 屏障**
- 禁止：
  - 构造函数中的写操作
  - 被重排序到构造函数之外
- 保证其他线程看到对象时：
  - `final` 字段一定是初始化后的值

------

## 三、对比：`final` vs `volatile`

| 维度       | final              | volatile        |
| ---------- | ------------------ | --------------- |
| 可见性     | 仅对初始化完成有效 | 任意读写都可见  |
| 原子性     | ❌                  | ❌（仅保证可见） |
| 重排序限制 | 构造期禁止重排序   | 读写均禁止      |
| 使用场景   | 不可变对象         | 状态共享变量    |

------

## 四、示例说明

### ✅ 正确示例（安全发布）

```
class User {
    final int age;

    User() {
        age = 18;
    }
}
```

- 多线程访问 `User.age` 一定是 18

------

### ❌ 错误示例（构造函数逸出）

```
class User {
    final int age;

    User() {
        age = 18;
        Registry.register(this); // this 逸出
    }
}
```

- 其他线程可能看到 `age = 0`

------

## 五、final 为什么常用于不可变对象？

- `String`
- `Integer`
- `Long`

原因：

- `final` + 构造期初始化
- JVM 提供初始化安全性
- 天然线程安全

------

## 七、面试官可能的追问（加分）

- ❓ `final` 能替代 `volatile` 吗？
  - ❌ 不能，`final` 只对初始化生效
- ❓ `final` 数组能保证元素不可变吗？
  - ❌ 只能保证引用不可变，元素可变