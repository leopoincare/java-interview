## Java 中什么情况会导致死锁？如何避免？

这是 **Java 并发面试必考题**，不仅要知道**什么是死锁**，还要能说清楚 **产生条件 + 实际场景 + 解决方案**。下面我按 **定义 → 产生条件 → 常见场景 → 避免方式 → 面试总结** 来讲。

## 面试总结一句话

> **Java 死锁发生在多个线程交叉持有并等待资源，满足互斥、请求并持有、不可剥夺、循环等待四个条件，通过固定加锁顺序、tryLock 超时和减少锁粒度可以有效避免。**

------

## 一、什么是死锁（Deadlock）？

> **死锁是指多个线程相互持有对方需要的资源，并且都在等待对方释放资源，导致所有线程永久阻塞。**

------

## 二、死锁产生的四个必要条件（必背 ⭐）

> **四个条件同时满足，死锁才会发生**

1️⃣ **互斥条件**

- 资源一次只能被一个线程占用（如锁）

2️⃣ **请求并持有**

- 线程已经持有资源，又继续请求新资源

3️⃣ **不可剥夺**

- 已获取的资源不能被强制抢占，只能主动释放

4️⃣ **循环等待**

- 存在一个线程—资源的环形等待关系

👉 **破坏任意一个条件即可避免死锁**

------

## 三、Java 中常见死锁场景

### 1️⃣ 多个锁交叉获取（最常见）

```
Object lockA = new Object();
Object lockB = new Object();

Thread t1 = new Thread(() -> {
    synchronized (lockA) {
        synchronized (lockB) { }
    }
});

Thread t2 = new Thread(() -> {
    synchronized (lockB) {
        synchronized (lockA) { }
    }
});
```

📌 现象：

- t1 拿 A 等 B
- t2 拿 B 等 A

------

### 2️⃣ 数据库 + Java 锁混用

- 线程 A：先拿 Java 锁，再拿 DB 锁
- 线程 B：先拿 DB 锁，再拿 Java 锁

------

### 3️⃣ 线程池相互等待

- 线程池线程数不足
- 任务内部调用 `Future.get()` 等待另一个任务完成

------

## 四、如何避免死锁？（重点）

### 1️⃣ 固定锁顺序（最常用）

```
// 所有线程统一先拿 lockA 再拿 lockB
```

✅ 破坏「循环等待」

------

### 2️⃣ 使用 `tryLock()` + 超时机制

```
if (lock.tryLock(1, TimeUnit.SECONDS)) {
    try {
        // 业务逻辑
    } finally {
        lock.unlock();
    }
}
```

✅ 破坏「不可剥夺」

------

### 3️⃣ 减少锁粒度、缩小锁范围

- 不要在锁内做 I/O、RPC、sleep
- 能用局部锁就不用全局锁

------

### 4️⃣ 使用并发工具类

- `ConcurrentHashMap`
- `AtomicXXX`
- `BlockingQueue`

------

### 5️⃣ 合理设计线程池

- 避免线程池任务互相等待
- 拆分线程池

------

## 五、如何定位死锁（加分项 ⭐）

### 1️⃣ jstack

```
jstack pid
```

- JVM 会直接标出：

```
Found one Java-level deadlock
```

### 2️⃣ 监控工具

- JConsole
- VisualVM

------

## 面试官常见追问

- ❓ synchronized 一定会死锁吗？
   👉 不一定，逻辑设计不当才会
- ❓ tryLock 为什么能避免死锁？
   👉 可放弃等待，破坏不可剥夺
- ❓ CAS 会不会死锁？
   👉 不会，但可能活锁