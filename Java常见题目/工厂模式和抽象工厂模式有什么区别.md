## 工厂模式和抽象工厂模式有什么区别

工厂模式和抽象工厂模式都属于 **创建型设计模式**，核心目标都是**解耦对象的创建与使用**，但侧重点和适用场景不同。下面从概念、结构和使用场景对比说明，适合面试回答。

------

## 面试总结一句话 

> **工厂模式关注“一个产品怎么创建”，抽象工厂模式关注“一整套相关产品如何成组创建”。**

## 一、工厂模式（Factory Method）

### 1️⃣ 定义

> 定义一个创建对象的接口，让子类决定实例化哪一个类。

👉 **一个工厂方法，对应创建一种产品等级结构**。

------

### 2️⃣ 结构特点

- 抽象产品（Product）
- 具体产品（ConcreteProduct）
- 抽象工厂（Factory）
- 具体工厂（ConcreteFactory）

------

### 3️⃣ 示例

```
// 产品接口
interface Car {
    void drive();
}

// 具体产品
class Tesla implements Car {
    public void drive() {}
}

class Bmw implements Car {
    public void drive() {}
}

// 工厂接口
interface CarFactory {
    Car createCar();
}

// 具体工厂
class TeslaFactory implements CarFactory {
    public Car createCar() {
        return new Tesla();
    }
}
```

------

### 4️⃣ 适用场景

- 只需要创建 **一种类型的产品**
- 产品数量可能扩展
- 希望通过工厂屏蔽 `new` 关键字

------

## 二、抽象工厂模式（Abstract Factory）

### 1️⃣ 定义

> 提供一个接口，用于创建**一系列相关或相互依赖的对象**，而无需指定具体类。

👉 **一个工厂，创建一整套产品族**。

------

### 2️⃣ 结构特点

- 多个抽象产品（ProductA / ProductB）
- 多个具体产品（ConcreteProductA1 / B1）
- 抽象工厂（AbstractFactory）
- 具体工厂（ConcreteFactory）

------

### 3️⃣ 示例

```
// 抽象产品
interface Engine {}
interface Tire {}

// 具体产品
class ElectricEngine implements Engine {}
class ElectricTire implements Tire {}

class FuelEngine implements Engine {}
class FuelTire implements Tire {}

// 抽象工厂
interface CarFactory {
    Engine createEngine();
    Tire createTire();
}

// 具体工厂
class ElectricCarFactory implements CarFactory {
    public Engine createEngine() { return new ElectricEngine(); }
    public Tire createTire() { return new ElectricTire(); }
}
```

------

### 4️⃣ 适用场景

- 需要创建 **多个相关联的产品**
- 强调产品之间的 **一致性**
- 希望整体切换产品族（如电动车 / 燃油车）

------

## 三、核心区别对比（面试重点）

| 对比维度 | 工厂模式             | 抽象工厂模式           |
| -------- | -------------------- | ---------------------- |
| 创建对象 | 单一产品             | 一组相关产品           |
| 工厂职责 | 一个工厂负责一种产品 | 一个工厂负责一个产品族 |
| 扩展方向 | 扩展产品类型         | 扩展产品族             |
| 复杂度   | 较低                 | 较高                   |
| 常见场景 | 单一对象创建         | 跨平台 / 组件配套      |

------

##  

## **简单工厂 / 工厂方法 / 抽象工厂** 三种创建型模式。

## 面试总结一句话

> **简单工厂通过条件判断创建对象，工厂方法通过子类决定对象创建，抽象工厂通过一个工厂创建一整套相关产品。**

------

## 一、一句话理解三种工厂模式 ⭐

- **简单工厂**：
   👉 *一个工厂，通过条件判断创建不同产品*
- **工厂方法**：
   👉 *一个产品一个工厂，延迟到子类决定创建哪种产品*
- **抽象工厂**：
   👉 *一个工厂，创建一整套相关产品*

------

## 二、三种模式结构对比（重点）

| 维度             | 简单工厂     | 工厂方法   | 抽象工厂       |
| ---------------- | ------------ | ---------- | -------------- |
| 工厂数量         | 一个         | 多个       | 多个           |
| 产品种类         | 多种         | 一种       | 多种（产品族） |
| 是否符合开闭原则 | ❌ 不符合     | ✅ 符合     | ✅ 符合         |
| 扩展方式         | 修改工厂代码 | 新增工厂类 | 新增产品族工厂 |
| 复杂度           | 最低         | 中等       | 最高           |
| 使用频率         | 低           | 高         | 较高           |

------

## 三、核心区别拆解

### 1️⃣ 简单工厂（Simple Factory）

**特点**

- 通过 `if / switch` 创建对象
- 把对象创建逻辑集中在一个类中

```
class CarFactory {
    public static Car create(String type) {
        if ("BMW".equals(type)) return new Bmw();
        if ("Tesla".equals(type)) return new Tesla();
        return null;
    }
}
```

**优点**

- 实现简单
- 客户端使用方便

**缺点**

- 新增产品需要修改工厂代码
- 违反开闭原则

**适用场景**

- 产品种类少
- 对扩展要求不高

------

### 2️⃣ 工厂方法（Factory Method）

**特点**

- 一个产品对应一个工厂
- 把对象创建延迟到子类

```
interface CarFactory {
    Car createCar();
}
class TeslaFactory implements CarFactory {
    public Car createCar() {
        return new Tesla();
    }
}
```

**优点**

- 符合开闭原则
- 扩展性好

**缺点**

- 类数量增加

**适用场景**

- 单一产品类型
- 需要频繁扩展产品

------

### 3️⃣ 抽象工厂（Abstract Factory）

**特点**

- 一个工厂创建多个相关产品
- 强调产品族的一致性

```
interface CarFactory {
    Engine createEngine();
    Tire createTire();
}
```

**优点**

- 保证产品族搭配一致
- 易于整体替换产品族

**缺点**

- 结构复杂
- 新增产品等级结构困难

**适用场景**

- 多产品组合
- 跨平台 / 跨系列系统

------

## 四、面试高频对比总结 ⭐

| 问法                 | 回答思路            |
| -------------------- | ------------------- |
| 三种工厂模式区别？   | 创建粒度不同        |
| 为什么不用简单工厂？ | 不符合开闭原则      |
| 抽象工厂适合什么？   | 产品族切换          |
| Spring 用了哪种？    | 工厂方法 + 抽象工厂 |

------

