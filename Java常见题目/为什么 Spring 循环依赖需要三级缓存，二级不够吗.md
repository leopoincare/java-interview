## 为什么 Spring 循环依赖需要三级缓存，二级不够吗

这是 **Spring 循环依赖的高频“灵魂追问”**。如果你只回答“为了解决循环依赖”，面试官一般不会满意；关键在于 **为什么一定要三级缓存、二级为什么不够、它解决了什么更深层的问题**。

我按 **结论 → 缓存结构 → 二级为什么不够 → 三级如何解决 → 面试总结** 来讲。

------

## 面试总结一句话

> **Spring 使用三级缓存解决循环依赖，是为了在提前暴露 Bean 的同时兼容 AOP，通过 ObjectFactory 延迟创建代理对象，避免原始对象和代理对象混用，二级缓存无法满足这一点。**

------

## 一、一句话结论（先给结论 ⭐）

> **Spring 使用三级缓存，是为了解决“循环依赖 + AOP 代理”同时存在的问题；仅有二级缓存无法区分“原始对象”和“代理对象”的暴露时机。**

------

## 二、Spring 解决循环依赖的三级缓存结构

以 `DefaultSingletonBeanRegistry` 为核心：

| 缓存     | 名称                    | 作用                                         |
| -------- | ----------------------- | -------------------------------------------- |
| 一级缓存 | `singletonObjects`      | 完整初始化好的 Bean                          |
| 二级缓存 | `earlySingletonObjects` | 提前暴露的**半成品 Bean**                    |
| 三级缓存 | `singletonFactories`    | 生成 Bean 的 **ObjectFactory（可生成代理）** |

------

## 三、如果只有二级缓存，会发生什么问题？

### 假设场景（经典）

```
@Service
class A {
    @Autowired
    private B b;
}

@Service
class B {
    @Autowired
    private A a;
}
```

并且 **A 或 B 有 AOP 代理**（如 `@Transactional`）。

------

### 仅二级缓存的流程（问题点 ❌）

1. 创建 A
2. A 实例化完成（未注入 B）
3. **直接把 A 的原始对象放入二级缓存**
4. 开始创建 B
5. B 依赖 A → 从二级缓存拿到 **原始 A**
6. B 初始化完成
7. 回到 A，完成依赖注入
8. A 需要创建代理（AOP）

❌ **问题出现：**

- B 中注入的是 **原始 A**
- 容器最终使用的是 **代理 A**
- 同一个 Bean，容器中出现了 **两个形态**

👉 **AOP 失效 / 行为不一致**

------

## 四、三级缓存是如何解决这个问题的？

### 三级缓存的核心思想

> **不提前暴露对象本身，而是提前暴露“获取对象的能力”。**

------

### 三级缓存流程（正确 ✔）

1. 创建 A

2. A 实例化完成

3. 放入三级缓存：

   ```
   singletonFactories.put("A", () -> getEarlyBeanReference(A));
   ```

4. 创建 B

5. B 依赖 A → 触发 `ObjectFactory`

6. 如果 A 需要代理：

   - **此时创建代理对象**

7. 将代理 A 放入二级缓存

8. B 注入的是 **代理 A**

9. A 初始化完成 → 放入一级缓存

✔ **整个容器中 A 只有一个形态（代理对象）**

------

## 五、二级 vs 三级缓存的本质区别（重点 ⭐）

| 对比点             | 二级缓存 | 三级缓存 |
| ------------------ | -------- | -------- |
| 暴露内容           | 对象本身 | 对象工厂 |
| 是否支持 AOP       | ❌        | ✅        |
| 是否延迟创建代理   | ❌        | ✅        |
| 是否解决代理一致性 | ❌        | ✅        |

------

## 六、为什么不在实例化时就创建代理？

- AOP 依赖 BeanPostProcessor
- BeanPostProcessor 在 **实例化之后、初始化前后**
- 提前创建代理：
  - 生命周期不完整
  - 破坏扩展点顺序

👉 所以 **只能在三级缓存阶段“按需生成代理”**

------

## 面试官常见加分追问

- ❓ 为什么 Spring 只能解决 **单例** 的循环依赖？
- ❓ 构造器循环依赖为什么解决不了？
- ❓ prototype Bean 为什么不支持循环依赖？
- ❓ Spring 为什么不支持多例的三级缓存？

## 🎯 面试终极总结一句话

> **Spring 的循环依赖解决机制基于单例 Bean 的生命周期托管，通过三级缓存提前暴露实例引用；构造器注入因无实例可暴露无法解决，而 prototype Bean 由于实例不唯一和生命周期不可控，Spring 明确不支持循环依赖。**

## ❓ 1. 为什么 Spring 只能解决 **单例（singleton）** 的循环依赖？

### 一句话结论 ⭐

> **因为 Spring 的三级缓存是围绕“单例 Bean 的全局唯一性”设计的，而多例 Bean 没有统一的缓存生命周期。**

### 核心原因

- 单例 Bean：
  - **容器级唯一**
  - 生命周期由 Spring 完全托管
  - 可以安全缓存“半成品”
- 多例 Bean：
  - 每次 `getBean()` 都新建
  - 容器不保存完整生命周期
  - 无法复用提前暴露的对象

📌 三级缓存本质：
 👉 **缓存的是“正在创建中的单例 Bean”**

### 关键词

```
生命周期托管` / `容器唯一实例
```

------

## ❓ 2. 构造器循环依赖为什么解决不了？

### 一句话结论 ⭐

> **构造器注入发生在对象实例化之前，此时 Bean 实例尚不存在，无法提前暴露引用。**

### 原因分析

```
class A {
    A(B b) {}
}

class B {
    B(A a) {}
}
```

创建 A → 必须先有 B
 创建 B → 必须先有 A

❌ **死结出现：**

- 实例都还没创建
- 三级缓存只能在 **实例化之后** 才能介入
- 无法“先给一个空壳引用”

📌 Spring 的循环依赖解决方案：

> **前提是：Bean 必须已经完成实例化**

### 关键词

```
实例化前依赖` / `无引用可暴露
```

------

## ❓ 3. 为什么 prototype Bean 不支持循环依赖？

### 一句话结论 ⭐

> **prototype Bean 生命周期不受 Spring 完全管理，容器无法缓存和复用其半成品对象。**

### 具体原因

- prototype Bean：
  - Spring 只负责创建
  - **不管理销毁**
  - 不放入单例缓存
- 循环依赖需要：
  - 提前暴露
  - 多次引用同一对象

❌ prototype 每次都是新对象
 → 提前暴露失去意义

### 官方行为

```
BeanCurrentlyInCreationException
```

### 关键词

```
每次创建新实例` / `无法缓存半成品
```

------

## ❓ 4. Spring 为什么不支持多例（prototype）的三级缓存？

### 一句话结论 ⭐

> **多例 Bean 不具备“全局唯一性”，三级缓存会导致实例混乱、内存泄漏和语义错误。**

### 深层原因

- 三级缓存设计前提：
  - Bean 名称 → 唯一实例
- prototype Bean：
  - Bean 名称 → 多个实例
- 若强行缓存：
  - 不知道缓存的是哪一次创建
  - 多线程下存在严重安全问题
  - 生命周期不可控

📌 这是 **架构级取舍，不是技术能力不足**

### 关键词

```
实例语义不唯一` / `设计边界
```

------

## 🧠 四问对照速记表（面试神器）

| 问题             | 核心原因          |
| ---------------- | ----------------- |
| 只支持单例       | 生命周期 & 唯一性 |
| 构造器不支持     | 无法提前暴露      |
| prototype 不支持 | 无缓存意义        |
| 无多例三级缓存   | 语义混乱          |

------

