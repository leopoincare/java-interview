## MySQL 三层 B+ 树能存多少数据？

这是一个 **InnoDB 索引容量的经典面试题**，考你是否真的理解 **B+ 树结构 + 页大小 + 指针/Key 大小**。下面我一步步算给你看，最后给**面试可直接背的结论**。

------

## 面试总结一句话

> **InnoDB 页大小为 16KB，非叶子节点分支因子约 1000，三层 B+ 树可容纳约千万级数据量，查询通常只需 2～3 次 IO，因此 MySQL 单表千万级数据性能仍然稳定。**

## 

## 一、先给结论（面试秒答版 ⭐）

> **在 InnoDB 中，一棵 3 层 B+ 树大约可以存 1000 万～2000 万行数据（典型主键 int）。**

------

## 二、计算前的几个关键前提（面试官默认你知道）

### InnoDB 基本设定

- **页（Page）大小**：16KB
- **B+ 树高度**：3 层
  - root
  - internal
  - leaf（存数据）

### 假设（常规面试假设）

- 主键：`INT`（4B）
- 指针（页号）：6B
- 单条索引项 ≈ **10～16B**
- 单行数据大小 ≈ **1KB（保守估计）**

------

## 三、一步步算（重点 ⭐）

------

### 1️⃣ 非叶子节点能存多少指针？

非叶子节点存的是：

```
key + child_page_pointer
```

按 **16B** 估算一条索引项：

```
16KB / 16B ≈ 1000 个指针
```

👉 一个非叶子节点 ≈ **1000 个子节点**

------

### 2️⃣ 三层 B+ 树的结构

```
            Root
          /  |  \
       1000 个子节点
        ↓
   1000 个 internal nodes
        ↓
   1000 个 leaf pages
```

👉 **叶子页数量 ≈ 1000 × 1000 = 1,000,000**

------

### 3️⃣ 每个叶子页能存多少行？

- 页大小：16KB
- 单行：1KB

```
16KB / 1KB ≈ 16 行
```

------

### 4️⃣ 总行数计算

```
1,000,000 × 16 ≈ 16,000,000 行
```

👉 **≈ 1600 万行**

------

## 四、为什么有人说「3 层能放上亿」？

因为他们的假设不同：

| 假设变化       | 影响               |
| -------------- | ------------------ |
| 行更小（100B） | 行数 ↑             |
| 主键更短       | 分支因子 ↑         |
| 覆盖索引       | 叶子节点不存整行   |
| 二级索引       | 容量远大于聚簇索引 |

📌 **二级索引 3 层 → 上亿很正常**

------

## 五、不同场景下的数量级总结

| 场景                | 3 层 B+ 树容量 |
| ------------------- | -------------- |
| 聚簇索引（1KB 行）  | ~1000 万       |
| 聚簇索引（500B 行） | ~3000 万       |
| 二级索引            | ~1 亿+         |
| 覆盖索引            | 更大           |

------

## 六、为什么 MySQL 很少超过 3～4 层？

- B+ 树**分支因子极大**
- 3 层：
  - 2 次磁盘 IO
- 4 层：
  - 3 次磁盘 IO
- Buffer Pool 命中率高，root / internal 常驻内存

👉 **性能非常稳定**

------

## 面试官可能继续追问

- ❓ 为什么不把页搞大一点？
- ❓ UUID 主键对 B+ 树高度有什么影响？
- ❓ 二级索引为什么能存更多？
- ❓ 表到多大需要分库分表？

下面这 4 个问题是 **B+ 树容量题的“追问四连击”**，我按 ***attach 原理 → 影响 → 面试一句话\* 的方式给你一套**可直接背**的答案。

------

## 1️⃣ 为什么不把 InnoDB 页搞大一点？

### 表面看

> 页越大 → 一页存更多记录 → 树更矮 → IO 更少

### 真实代价（重点）

#### 1. 随机 IO 成本上升

- B+ 树访问是 **随机读**
- 读 64KB 但只用其中一小部分 → 浪费 IO

#### 2. 内存命中率下降

- Buffer Pool 固定
- 页变大 → 能缓存的页变少

#### 3. 页分裂 / 合并成本变高

- 页越大，移动数据越多
- 写放大严重

#### 4. 16KB 是综合权衡

- 磁盘 IO
- 内存
- CPU cache

📌 MySQL 官方结论：**16KB 是长期验证后的最佳折中**

### 面试一句话

> **页不能无限变大，否则会增加随机 IO、降低缓存命中率并加重页分裂成本，16KB 是性能和资源的平衡点。**

------

## 2️⃣ UUID 主键对 B+ 树高度有什么影响？

### 核心影响：**不是高度，而是结构稳定性**

#### 1. 随机 UUID

- 插入位置随机
- 大量 **页分裂**
- 树结构频繁调整

#### 2. 页分裂后果

- 索引碎片严重
- Buffer Pool 命中率下降
- 写性能明显下降

#### 3. B+ 树高度变化？

- 高度可能**更早增加**
- 但真正的问题是 **写性能和碎片**

📌 对比：

| 主键    | 插入行为     |
| ------- | ------------ |
| 自增 ID | 右侧顺序插入 |
| UUID    | 全树随机插入 |

### 面试一句话

> **UUID 主键会导致 B+ 树频繁页分裂和碎片化，影响写性能，并可能更早增加树高度。**

------

## 3️⃣ 为什么二级索引能存更多数据？

### 核心原因：**叶子节点更小**

#### 聚簇索引叶子

```
[ 主键 + 整行数据 ]
```

#### 二级索引叶子

```
[ 二级索引列 + 主键 ]
```

👉 **不存整行数据**

------

### 数量级差异

| 索引类型 | 叶子页存储   |
| -------- | ------------ |
| 聚簇索引 | 10～20 行    |
| 二级索引 | 几百～上千条 |

👉 同样 3 层树：

- 聚簇索引：千万级
- 二级索引：**上亿级**

### 面试一句话

> **二级索引叶子节点只存索引列和主键，单条记录更小，因此同样高度能容纳更多数据。**

------

## 4️⃣ 表到多大需要分库分表？

### 关键点（不是一个固定数字）

> **分库分表不是因为“数据量”，而是因为“性能瓶颈”**

------

### 常见经验阈值（参考）

| 指标     | 建议             |
| -------- | ---------------- |
| 单表行数 | 2000 万～5000 万 |
| 表大小   | 10～50 GB        |
| 索引层级 | ≥4 层            |
| TPS      | 单表 QPS 上万    |
| 热点 IO  | 明显             |

📌 满足其中 **2～3 项**，就该考虑拆分

------

### 什么时候不需要？

- 查询走覆盖索引
- 冷数据为主
- 读多写少
- Buffer Pool 足够大

------

### 面试一句话

> **分库分表的触发点不是表多大，而是单表已成为性能瓶颈，一般在千万级数据量、索引层级升高或 IO、锁竞争明显时考虑。**

------

## 🧠 四连问终极速记版（面试 30 秒）

> - 页不能无限大，否则随机 IO 和页分裂成本过高
> - UUID 主键导致随机插入，页分裂和碎片严重
> - 二级索引不存整行，叶子更小，容量更大
> - 分库分表看性能瓶颈而非单纯数据量