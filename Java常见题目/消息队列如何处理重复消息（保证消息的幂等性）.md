## 消息队列如何处理重复消息（保证消息的幂等性）？

这是**消息队列（MQ）面试必考题**，核心点就是：**MQ 只能保证“至少一次”，幂等性必须由消费者来兜底**。我按 **问题 → 原因 → 常见方案 → 场景示例 → 面试一句话** 给你总结。

------

## 面试总结一句话

> **消息队列无法完全避免重复消息，必须在消费者端通过唯一业务标识、数据库唯一约束或去重表等方式保证业务幂等性。**

## 一、为什么会出现重复消息？

MQ 在实际运行中，**重复消息是不可避免的**，常见原因有：

1. **消费者处理成功，但 ACK 丢失**
2. **消费者处理超时，被 MQ 重新投递**
3. **生产者重试发送**
4. **Broker 主从切换 / 网络抖动**

👉 所以大多数 MQ（Kafka / RocketMQ / RabbitMQ）都只能保证：

> **At-Least-Once（至少一次）**

------

## 二、什么是幂等性？

> **幂等性**：同一条消息被消费一次或多次，**业务结果一致**。

------

## 三、处理重复消息的核心思想 ⭐

> **为每条消息设置“唯一业务标识”，消费者基于该标识做去重。**

------

## 四、常见幂等性解决方案（重点）

### 1️⃣ 数据库唯一约束（最常用）

**做法**

- 消息中带 `bizId / orderId`
- 数据库建立唯一索引

```
CREATE UNIQUE INDEX uk_order_id ON order(order_id);
```

**消费逻辑**

```
插入成功 → 第一次消费
插入失败 → 重复消息，直接忽略
```

**优点**

- 实现简单
- 强一致性

**缺点**

- 依赖数据库

------

### 2️⃣ Redis 去重（高性能）

**做法**

```
SETNX msgId 1 EX 600
```

- 成功 → 第一次消费
- 失败 → 重复消息

**适用场景**

- 高并发
- 允许少量时间窗口内去重

**注意**

- 需要设置过期时间
- Redis 宕机会导致重复

------

### 3️⃣ 消息表（去重表）⭐

**做法**

- 消费前先插入 `message_log` 表（唯一索引）
- 插入成功 → 执行业务
- 插入失败 → 已消费，直接返回

**特点**

- 可追溯
- 常用于金融、订单系统

------

### 4️⃣ 状态机 / 业务幂等设计

**示例：订单状态流转**

```
NEW → PAID → SHIPPED
```

- 已 PAID 再收到 PAID 消息 → 直接忽略
- 状态不可逆

**优点**

- 业务层天然幂等
- 非常可靠

------

### 5️⃣ MQ 自带能力（辅助）

| MQ       | 能力                                 |
| -------- | ------------------------------------ |
| Kafka    | Exactly Once（事务 + 幂等 Producer） |
| RocketMQ | 业务幂等 + 消息唯一 Key              |
| RabbitMQ | 消费端幂等                           |

👉 **注意：Exactly Once ≠ 业务幂等**

------

## 五、生产级推荐组合 ⭐

```
MQ 至少一次
↓
消费者幂等设计
↓
数据库唯一约束 / 去重表
↓
必要时 Redis 提前拦截
```

------

## 六、示例：订单支付消息

```
消息：orderId=1001
```

消费者逻辑：

1. 判断订单是否已支付
2. 已支付 → 直接 ACK
3. 未支付 → 执行支付逻辑 → 更新状态

------

## 面试官常见追问

- ❓ Kafka 的 Exactly Once 能解决重复吗？
  - 只能保证 Kafka 内部语义，**不能保证业务幂等**
- ❓ Redis 去重可靠吗？
  - 高性能但非强一致，关键业务仍需落库