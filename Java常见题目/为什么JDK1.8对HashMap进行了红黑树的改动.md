## 为什么 JDK 1.8 对 HashMap 进行了红黑树的改动?

这是 **HashMap 面试中“为什么”类问题的王者级考点**，问的是**设计动机而不是用法**。下面我从**问题背景 → 解决方案 → 为什么是红黑树 → 为什么是 8**，一步一步讲清楚。

## 面试一句话总结

> **JDK 1.8 引入红黑树，是为了解决 HashMap 在高冲突场景下链表过长导致的性能退化和安全问题，通过在链表长度超过阈值时转为红黑树，将最坏时间复杂度从 O(n) 限制到 O(log n)，在性能和内存之间取得平衡。**

------

## 一、问题背景：JDK 1.7 的 HashMap 有什么问题？

### 1️⃣ 冲突严重时性能退化

JDK 1.7 之前，HashMap 的桶结构是：

```
数组 + 链表
```

当发生大量 hash 冲突时：

```
table[i] → Node → Node → Node → ...（很长的链表）
```

- `get / put` 时间复杂度：
  - **平均：O(1)**
  - **最坏：O(n)**

> 在极端情况下，HashMap 会退化成“链表 + 顺序查找”。

------

### 2️⃣ 真实风险：Hash 冲突攻击（安全问题）

如果攻击者**刻意构造 hashCode 相同的 key**（例如 HTTP 参数、JSON key）：

- 所有 key 落到同一个桶
- 链表非常长
- CPU 飙升
- 服务不可用（DoS 攻击）

⚠️ 这是 **现实中发生过的安全问题**，并不是理论推导。

------

## 二、JDK 1.8 的解决方案：链表 → 红黑树

### 1️⃣ 为什么引入红黑树？

红黑树是**近似平衡的二叉搜索树**：

| 数据结构 | 查找复杂度   |
| -------- | ------------ |
| 链表     | O(n)         |
| 红黑树   | **O(log n)** |

👉 即使所有 key 冲突在同一个桶里，也能保证性能上限。

------

### 2️⃣ 设计目标

JDK 1.8 的设计目标不是提升**平均性能**，而是：

> **保证 HashMap 的“最坏情况性能”不会失控**

------

## 三、为什么不用 AVL / B+ 树 / 跳表？

### 🔹 为什么不是 AVL 树？

- AVL 更严格平衡
- 插入 / 删除旋转次数多
- 写性能差

### 🔹 为什么不是 B+ 树？

- 适合磁盘 / IO
- HashMap 在内存中使用

### 🔹 为什么不是跳表？

- 指针更多
- 内存占用高
- 常数因子大

✅ **红黑树是“性能 + 内存 + 实现复杂度”的最佳平衡点**

------

## 四、为什么不是一开始就用红黑树？

### 1️⃣ 小链表更快

当链表很短时：

- 红黑树：
  - 节点多
  - 旋转、染色成本高
- 链表：
  - CPU Cache 友好
  - 实现简单

👉 **链表在元素很少时反而更快**

------

### 2️⃣ 空间成本问题

红黑树节点（TreeNode）比普通 Node：

- 多 parent / left / right / color
- 内存占用明显增加

------

## 五、为什么树化阈值是 8？（超高频）

### 1️⃣ 概率论依据（泊松分布）

在理想 hash 分布下：

- 链表长度 ≥ 8 的概率：
  - **小于千万分之一**

👉 正常情况下几乎不会树化
 👉 一旦发生，极可能是 **hash 设计不良或攻击**

------

### 2️⃣ 性能折中

| 长度 | 处理方式       |
| ---- | -------------- |
| < 8  | 链表（更快）   |
| ≥ 8  | 红黑树（更稳） |

------

### 3️⃣ 还有一个隐藏条件（容易被忽略）

```
if (binCount >= TREEIFY_THRESHOLD - 1
    && table.length >= MIN_TREEIFY_CAPACITY) {
    treeifyBin();
}
```

- `MIN_TREEIFY_CAPACITY = 64`
- **数组太小时，不树化，而是优先扩容**

👉 避免“小表 + 树”这种反优化

------

## 六、为什么退化阈值是 6？

- 防止 **频繁 链表 ↔ 树 来回切换**
- 加一个 **滞后区间（hysteresis）**

```
树化：8
退化：6
```

------

## 七、设计收益总结

### 引入红黑树带来的好处

✅ 保证最坏时间复杂度 O(log n)
 ✅ 防御 hash 冲突攻击
 ✅ 提升大数据量场景稳定性
 ✅ 对正常场景几乎零影响

------

> 