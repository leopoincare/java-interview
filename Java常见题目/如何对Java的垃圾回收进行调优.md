## 如何对 Java 的垃圾回收进行调优？

这是 **JVM 面试 + 实战调优** 的高频题，不是简单背参数，而是要体现**方法论**。我按 **“什么时候调 → 怎么调 → 常用参数 → 面试一句话”** 给你讲清楚。

------

## 面试总结一句话

> **Java GC 调优应以 GC 日志为依据，结合业务场景选择合适的回收器，通过调整堆结构、晋升策略和代码优化，减少 Full GC 次数和 STW 时间。**

------

## 一、什么时候需要做 GC 调优？（先判断）

不是所有系统都需要调 GC，**出现以下现象才有必要**：

- Full GC 频繁
- 接口 RT 抖动、偶发卡顿
- 吞吐量下降，CPU 飙高
- 老年代增长过快
- STW（Stop-The-World）时间过长

------

## 二、GC 调优的正确步骤（面试重点 ⭐）

### 1️⃣ 开启 GC 日志（必做）

```
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/path/gc.log
```

（JDK 9+）

```
-Xlog:gc*,gc+heap=info
```

👉 **没有 GC 日志，谈调优都是耍流氓**

------

### 2️⃣ 分析 GC 日志

重点关注：

| 指标                    | 含义               |
| ----------------------- | ------------------ |
| Young GC / Full GC 次数 | 是否频繁           |
| GC 停顿时间             | 是否超过 SLA       |
| 晋升失败                | 对象过早进入老年代 |
| 老年代回收比例          | 是否回收不干净     |

工具：

- GCViewer
- GCEasy
- JDK 自带 `jstat`

------

### 3️⃣ 选择合适的垃圾回收器（非常重要）

| 场景     | 推荐 GC          |
| -------- | ---------------- |
| 低延迟   | G1 / ZGC         |
| 高吞吐   | Parallel GC      |
| 大堆内存 | G1 / ZGC         |
| JDK 17+  | G1 / ZGC（首选） |

------

## 三、常见调优方向（核心经验）

### 1️⃣ 堆内存大小设置

```
-Xms4g
-Xmx4g
```

- 避免堆动态扩容
- 减少 Full GC

------

### 2️⃣ 新生代与老年代比例

```
-XX:NewRatio=2
```

或：

```
-Xmn2g
```

👉 新生代太小 → Young GC 频繁
 👉 太大 → 老年代不足，容易 Full GC

------

### 3️⃣ 对象晋升调优

```
-XX:MaxTenuringThreshold=15
-XX:SurvivorRatio=8
```

- 延迟对象进入老年代
- 降低 Full GC 风险

------

### 4️⃣ G1 常用调优参数（生产常见）

```
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:InitiatingHeapOccupancyPercent=45
```

- 控制最大停顿时间
- 提前触发并发标记

------

### 5️⃣ 避免大对象和内存泄漏（代码层）

- 减少临时大对象创建
- 注意缓存、集合未清理
- 使用堆转储分析：

```
-XX:+HeapDumpOnOutOfMemoryError
```

工具：

- MAT
- VisualVM

------

## 四、调优不是只调 JVM 参数（面试加分）

**代码层优化往往更重要**：

- 减少不必要对象创建
- 合理使用对象池
- 避免频繁创建大集合
- 注意 ThreadLocal 使用

------

## 五、调优思路总结（模板）

```
1. 发现问题（RT / GC 频繁）
2. 打开 GC 日志
3. 分析 GC 行为
4. 选择合适的 GC
5. 调整堆大小和参数
6. 优化代码和对象模型
```

------

## 面试官常见追问

- ❓ 为什么 Full GC 很慢？
- ❓ G1 如何控制停顿时间？
- ❓ ZGC 为什么几乎无停顿？
- ❓ CMS 为什么被废弃？

## 面试终极总结一句话

> **Full GC 慢在全堆 STW，G1 通过 Region 和预测模型控停顿，ZGC 通过全并发回收将停顿压到毫秒级，而 CMS 因碎片化和不可控已被淘汰。**

## ❓ 1. 为什么 Full GC 很慢？

### 一句话结论 ⭐

> **Full GC 慢是因为它需要对整个堆做 Stop-The-World 的标记、清理和整理操作。**

### 详细原因

- **回收范围大**：新生代 + 老年代（甚至方法区）
- **STW 时间长**：业务线程全部暂停
- **对象存活率高**：老年代对象多、回收少
- **内存整理（压缩）成本高**：需要大量对象移动

### 关键词

```
STW` / `全堆扫描` / `对象移动` / `老年代
```

------

## ❓ 2. G1 如何控制停顿时间？

### 一句话结论 ⭐

> **G1 通过将堆划分为 Region，并按“回收收益”优先回收部分 Region，从而在预测的时间内完成 GC。**

### 核心机制

1. **Region 化**

   - 堆被划分为多个大小相等的 Region（1–32MB）

2. **可预测模型**

   - 统计每个 Region 的回收成本和收益

3. **停顿目标**

   ```
   -XX:MaxGCPauseMillis=200
   ```

4. **优先回收垃圾最多的 Region**

👉 **不是一次回收整个堆**

### 关键词

```
Region` / `预测停顿时间` / `优先级回收
```

------

## ❓ 3. ZGC 为什么几乎无停顿？

### 一句话结论 ⭐

> **ZGC 将标记、重定位等重活全部并发执行，STW 只用于极少量的元数据操作。**

### 核心技术

1. **染色指针（Colored Pointer）**
   - 对象状态编码在指针中
2. **Load Barrier**
   - 在对象访问时修正引用
3. **并发压缩**
   - 对象移动不需要 STW
4. **STW 时间固定在毫秒级（<10ms）**

### 特点

- 与堆大小几乎无关
- 适合 TB 级内存

### 关键词

```
并发标记` / `并发重定位` / `Load Barrier
```

------

## ❓ 4. CMS 为什么被废弃？

### 一句话结论 ⭐

> **CMS 由于碎片化严重、CPU 消耗高、无法压缩内存，已被 G1 等更先进的 GC 替代。**

### CMS 的问题

1. **内存碎片**
   - 标记-清除，不压缩
2. **Full GC 风险**
   - 碎片多 → 分配失败 → STW Full GC
3. **并发失败（Concurrent Mode Failure）**
4. **参数复杂，维护成本高**

### 现状

- JDK 9 标记废弃
- JDK 14 正式移除

### 关键词

```
碎片化` / `Concurrent Mode Failure` / `已废弃
```

------

## 🧠 四问对比速记表（面试神器）

| 问题             | 核心答案          |
| ---------------- | ----------------- |
| Full GC 为什么慢 | STW + 全堆回收    |
| G1 如何控停顿    | Region + 收益优先 |
| ZGC 为什么快     | 全并发 + 染色指针 |
| CMS 为什么废弃   | 碎片化 + 不可控   |

