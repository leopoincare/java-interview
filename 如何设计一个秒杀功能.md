## 如何设计一个秒杀功能

秒杀系统是**高并发、高压力场景**的典型面试题，面试官考察的是 **系统架构、并发控制、性能优化和数据一致性**。我给你整理成 **思路 + 技术方案 + 面试总结句**，可以直接背。

------

## 面试总结一句话

> **秒杀系统通过缓存预减库存、请求排队、异步下单、限流防刷和数据库事务保证高并发下的性能和库存一致性。**

------

## 一、秒杀功能核心需求

1. **高并发**：瞬时请求量可能几万/秒
2. **库存正确**：不能超卖
3. **用户体验**：快速响应，避免系统崩溃
4. **高可用**：系统稳定运行

------

## 二、秒杀系统设计思路（分层）

### 1️⃣ 前端层

- **防刷机制**
  - 验证码、滑块
  - 登录限流
- **请求排队**
  - 用户请求先入队
  - 避免瞬时并发打垮后端

------

### 2️⃣ 接入层 / 网关

- **限流**
  - Nginx + Token Bucket / Leaky Bucket
- **降级**
  - 高峰期直接返回“系统繁忙，请稍后再试”
- **分布式防刷**
  - IP / UserID 限流

------

### 3️⃣ 应用层

#### a. 预减库存（核心）

- 使用 **Redis 原子操作**：
  - `decr` 或 Lua 脚本保证 **原子性**
  - 防止超卖
- 热点商品库存缓存到 Redis，减少数据库压力

#### b. 异步下单

- 秒杀请求写入 **消息队列**（Kafka / RocketMQ / RabbitMQ）
- 异步消费：
  - 扣库存
  - 生成订单

#### c. 数据库写入

- 库存、订单写入 **MySQL / TiDB**
- **乐观锁 / CAS** 防止库存超卖
- **事务**保证库存和订单一致

------

### 4️⃣ 数据层

- **数据库拆分 / 分库分表**
  - 高并发下避免单表/单库瓶颈
- **缓存**
  - Redis 缓存库存
  - 过期策略 + 预减库存

------

### 5️⃣ 系统优化手段

| 技术              | 作用                   |
| ----------------- | ---------------------- |
| Redis Lua 脚本    | 原子操作库存，防止超卖 |
| 消息队列异步处理  | 平滑高峰流量           |
| 令牌桶 / 漏桶限流 | 控制并发请求数量       |
| 本地内存缓存      | 降低 Redis 压力        |
| 异步下单          | 快速响应用户请求       |

------

## 三、关键点总结（面试必讲）

1. **秒杀热点商品库存** → Redis 缓存 + 原子减库存
2. **用户请求排队** → 避免 DB 超卖 / 堆积
3. **异步处理订单** → MQ + 消费者
4. **限流、防刷** → Nginx + 令牌桶
5. **数据一致性** → 乐观锁 / CAS / 事务

------

## 五、面试官常追问

- ❓ 如何保证 **库存不超卖**？
- ❓ Redis 预减库存失败怎么办？
- ❓ 消息队列宕机怎么办？
- ❓ 高并发下数据库如何设计？
- ❓ 秒杀请求如何快速返回响应？

------

## 1️⃣ 如何保证库存不超卖？

**方案：**

1. **Redis 原子操作**
   - 使用 `DECR` 或 Lua 脚本保证库存原子减少
   - 防止并发超卖
2. **数据库乐观锁 / CAS**
   - `UPDATE product SET stock=stock-1 WHERE stock>0`
   - 结合事务保证库存一致性
3. **预减 + 异步回补机制**
   - Redis 预减库存
   - 下单失败回补库存

### 面试一句话

> **通过 Redis 原子减库存和数据库乐观锁结合，保证高并发下库存不超卖。**

------

## 2️⃣ Redis 预减库存失败怎么办？

**方案：**

- **可能原因**：Redis 宕机、网络异常
- **处理方式**：
  1. 预减失败直接拒绝请求，返回“秒杀失败”
  2. 或使用本地内存标记限流，减少压力
  3. 后续异步补偿机制确保一致性

### 面试一句话

> **Redis 预减库存失败可立即拒绝请求，并通过本地缓存和异步补偿保证库存一致性。**

------

## 3️⃣ 消息队列宕机怎么办？

**方案：**

1. **持久化**
   - 使用 Kafka / RabbitMQ 的持久化机制
   - 消息不丢失
2. **本地落地或重试机制**
   - MQ 宕机 → 本地队列缓存
   - 系统恢复后重放消息
3. **限流 + 降级**
   - 高峰期减少入队请求
   - 保证核心服务可用

### 面试一句话

> **消息队列宕机可通过持久化、落地重试和限流降级保证订单不丢失。**

------

## 4️⃣ 高并发下数据库如何设计？

**方案：**

1. **分库分表**
   - 避免单库/单表成为瓶颈
2. **缓存 + 预减库存**
   - Redis 缓存热点商品库存
3. **异步写 DB**
   - 秒杀请求先写 MQ，后台异步下单
4. **索引和事务优化**
   - 索引合理，减少锁竞争
   - 使用短事务

### 面试一句话

> **高并发下数据库通过分库分表、缓存预减库存、异步写 DB 和事务优化来保证性能和一致性。**

------

## 5️⃣ 秒杀请求如何快速返回响应？

**方案：**

1. **异步下单 + MQ**
   - 秒杀请求立即返回排队结果或成功抢购状态
2. **Redis 预减库存**
   - 快速判断库存，避免 DB 阻塞
3. **本地内存限流**
   - 避免请求打爆 Redis 或 MQ
4. **返回状态码**
   - `success / queuing / sold out`
   - 用户体验友好，避免阻塞

### 面试一句话

> **通过 Redis 预减库存、异步下单和本地限流，秒杀请求可以立即返回状态，快速响应用户。**

------

### 🧠 秒杀追问速记版（面试 30 秒版）

> 1. Redis 原子减 + DB 乐观锁 → 防超卖
> 2. Redis 失败 → 拒绝 + 异步补偿
> 3. MQ 宕机 → 持久化 + 重试 + 限流
> 4. 高并发 DB → 分库分表 + 缓存 + 异步写入
> 5. 快速响应 → Redis 预减 + 异步下单 + 本地限流